# FP Mul

- Float * Float = Float? Yes.
- 교환법칙 성립? Yes.
- 결합법칙 성립? No.
> (1e20 * 1e20) * 1e-20 = inf
> (1e20 * 1e-20) * 1e20 = 1e20
> -> inf 처리 때문에 발생.
- 1을 곱해도 값이 유지? Yes.
- 분배법칙 성립? No
> 1e20 * (1e20-1e20) = 0.0
> 1e20 * 1e20 - 1e20 * 1e20 = NaN (inf - inf는 정의되지 않음)
> ->inf 처리 때문에 발생
- 단조성 유지? Almost(inf와 NaN 경우 제외)

# FP Add

- E1, E2 대소비교. 큰 쪽에 맞춤
- 작은 수를 shift
- add
- fixing(M>=2 면 E 증가, M<1 이면 E 감소)
  round 처리

- 교환법칙 성립? Yes.
- 결합법칙 성립? No.
> (3.14 + 1e20) - 1e20 = 0
> 3.14 + (1e20 - 1e20) = 3.14
> -> rounding 처리로 인한 손실
- 0을 더해도 같은 수? Yes.
- 덧셈해서 0이 나오는 수 존재? Almost(inf와 NaN 제외), signbit만 바꾸면 됨.
- 단조성 유지? Almost(inf와 NaN 경우 제외)

# FP Casting

- double/float -> int
	- frac부분을 int에 맞게 truncate
	- rounding 처리
	- NaN이 나오면 보통 TMin으로 변환
- int -> double
	-  완벽히 가능(유효숫자 자릿수가 52+1 bits > 32bits)
- int -> float
		-  완벽하진 않음(유효숫자 자릿수가 23 +1 bits < 32bits)


# Quiz
- int x, float f, double d
	-
		int -> float로 변환할 때 유효숫자가 int가 더 많기 때문에 문제가 생김
	-x == (int)(double) x
		int -> double은 완벽하게 가능. double의 유효숫자 자릿수가 52+1bit이 때문
		double -> int로 변환은 이미 x값이 int범위 내의 수이기 때문에 정확하게 가능
	-f == (float)(double) f
		float->double로 변환은 double이 표현할 수 있는 수의 범위가 더 크기 때문에 가능
	-d == (double)(float) d
		위와 반대로 double이 TMax값을 표현할 때 float는 해당 값을 표현하지 못함.
	-f == -(-f)
		float는 최상위 비트인 부호비트만 바꾸면 음수, 양수가 바뀌기 때문에 가능
	-2/3 == 2/3.0
		2/3.0은 2가 float로 변환되어 계산하는 반면 2/3은 정수로 계산되기 때문에 다름
	-d < 0.0 -> ((d * 2) < 0.0)
		맞음. -inf < 0 이기 때문
	-d > f == -f > -d
		inf일 때는 비교 불가하므로 inf인 경우가 자동으로 제외되니 맞음. 음수는 부호비트만 바꾸면 되기 때문
	-d * d >=0.0
		맞음. d가 NaN이 아니기 때문에 inf * inf를 해도 0보다 크기 때문
	-(d+f)-d == f
		d가 inf인 경우 d+f를 하면 inf가 나오기 때문에 inf-inf가 되므로 정의할 수 없으므로 NaN. 틀림.



    ---


# Assembly/Machine Code

- 어셈블리어의 동작
	- 연산
	- 데이터 이동 : memory <-> registor, registor<->registor
	- 제어 : 프로그램의 흐름 관리(for문, 함수 등등)

- 어셈블러 : 어셈블리어 -> 기계어 변환 (이 상태로는 실행 불가. 하나로 묶어야됨.)
- 링커 : 여러 파일들을 묶어줌.

# x86-64 Integer Registers

- 64비트 os에서는 registor가 16칸 있음. 한 칸의 크기는 8byte
- 한 칸의 크기가 8byte이지만 더 작은 크기를 사용할 때는 다른 이름으로 접근
  ex(%rax -> %eax -> %ah -> %al). 이 때 상위비트부터가 아닌 하위 비트부터 사용.
  => 과거 os들은 64비트보다 작은데 예전 os에서의 명령어도 처리하기 위해.

# 데이터 이동 명령어
- movq Source, Dest
  mov(q,l,w,b): 데이터 크기(괄호 안 문자에 따라..)만큼 크기를 갖는 Source 데이를 Dest로 이동(복사)시키겠다.

- %rax와 같이 %로 시작하면 레지스터.
- (%rax)와 같이 괄호 안에 표현되어 있으면 메모리 주소.
- Source에는 상수를 표현할 수 있음. $를 붙여 표현.

### Memory
- (%rax)는 메모리 주소값을 나타냄(pointer와 유사)
- %rax가 0x0101일 때
	- 괄호가 없으면 0x0101이라는 값.(변수 느낌)
	- 괄호가 있으면 0x0101이라는 주소에 있는 값.(포인터 느낌)
- 괄호 앞에 상수가 있으면 +의 의미
	- movq 8(%rax), %rbx : %rax+8의 주소에 있는 값.

- genereal한 표현식 : 상수1(레지스터 1, 레지스터 2, 상수 2)
	- 레지스터 1 + 상수2 * 레지스터 2 + 상수1
	- 상수 1은 1,2,4,8 만 쓸 수 있음.



- leaq Source, Dest
	- 주소만 계산하는 명령어.
- leaq 4(%rax), %rdx : %rax 값에 4를 곱한 주소값을 %rdx에 넣음. 

> 주소 자체를 연산하는 명령어이지만 주소와 값은 해석 한끗차이라는 것을 이용
> 주소처럼 계산하고 해석은 변수로
> 
> -> 상수 * 변수 가 있을 때 주로 사용.


