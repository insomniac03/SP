# FP Mul

- Float * Float = Float? Yes.
- 교환법칙 성립? Yes.
- 결합법칙 성립? No.
> (1e20 * 1e20) * 1e-20 = inf
> (1e20 * 1e-20) * 1e20 = 1e20
> -> inf 처리 때문에 발생.
- 1을 곱해도 값이 유지? Yes.
- 분배법칙 성립? No
> 1e20 * (1e20-1e20) = 0.0
> 1e20 * 1e20 - 1e20 * 1e20 = NaN (inf - inf는 정의되지 않음)
> ->inf 처리 때문에 발생
- 단조성 유지? Almost(inf와 NaN 경우 제외)

# FP Add

- E1, E2 대소비교. 큰 쪽에 맞춤
- 작은 수를 shift
- add
- fixing(M>=2 면 E 증가, M<1 이면 E 감소)
  round 처리

- 교환법칙 성립? Yes.
- 결합법칙 성립? No.
> (3.14 + 1e20) - 1e20 = 0
> 3.14 + (1e20 - 1e20) = 3.14
> -> rounding 처리로 인한 손실
- 0을 더해도 같은 수? Yes.
- 덧셈해서 0이 나오는 수 존재? Almost(inf와 NaN 제외), signbit만 바꾸면 됨.
- 단조성 유지? Almost(inf와 NaN 경우 제외)

# FP Casting

- double/float -> int
	- frac부분을 int에 맞게 truncate
	- rounding 처리
	- NaN이 나오면 보통 TMin으로 변환
- int -> double
	-  완벽히 가능(유효숫자 자릿수가 52 bits > 32bits)
- int -> float
	-  완벽하진 않음(유효숫자 자릿수가 23 bits > 32bits)
