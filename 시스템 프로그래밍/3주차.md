# Unsigned Power-of-2 Divide with Shift
-  u >> k : $2^k$ 로 나눈 몫을 구하는 것과 같다. (right shift)


    ```
    unsigned i;
    for (i = cnt-2; i>=0; i--)
	    a[i] += a[i+1];
    ```
- 문제점 : unsigned는 항상 0이상의 양의 정수를 가지기 때문에 무한 loop에 빠진다.

- 해결 코드
    ```
    unsigned i;
    for(i = cnt -2; i<cnt; i--)
		arr[i] += arr[i+1];
    ```
- i가 cnt보다 작을 때 까지만 반복 -> i의 값이 0보다 작아지게 되면 UMax가 되기 때문에 반복문 벗어남.

- x,y = signed. ux,uy = unsigned
> || 연산은 한쪽이 false임을 가정해 놓고 나머지 항이 false이면 false이다.

1.  (x > 0) || (x-1 < 0)
	   -> x<=0일 때(false 가정). x가 TMin이면 x-1은 양수가 된다.(false) = false
2.  (x & 7) != 7 || ((x << 29) < 0)
	   -> x&7은 하위 3비트만 남기겠다는 의미. 하위 3비트가 7일때, 즉 111로 끝날 때(false 가정). x<<29를 하면 하위 3비트가 상위 3비트가 되는데 MSB가 1이 되므로 무조건 음수이다(true) = true 
3.  (x * x) >= 0
	   -> singed의 곱셈은 항상 0이상의 양의 정수임을 보장할 수 없다.
4.  x < 0 || -x>=0
	   -> x>=0일 때(false 가정). x가 TMax이어도 TMin의 범위가 더 크기 때문에 항상 참이다(true) => true
5.  x > 0 || -x>=0
	   -> 위와 같은 논리로 false
6.  (x+y) == (ux + uy)
	   -> signed 의 덧셈과 unsigned의 덧셈 결과는 해석이 달라질 뿐 비트는 같다.
7.  (x * ~y) + (ux * uy) == -x
	   -> -y = ~y +1 이므로, ~y = -y-1이다. 정리하면 -xy-1 + (ux * uy) == -x
	   가 된다. signed 와 unsigned의 곱셈 결과는 해석이 달라질 뿐 비트는 변화가 없기 때문에 -xy와 ux * uy는 소거되고 -x만 남는다.

# Machine Words
- 각 컴퓨터는 "word size"가 정해져 있다.
- 한 주소는 1byte 저장   되지만, 실제로 다루는 size는 word size만큼 다룬다.

# Byte Ordering
-비트를 메모리에 저장하는 순서
> value  = 0x01234567
> address = 0x100
- Big Endian: 0x100 = 01 ~ 0x103 = 67 (낮은 주소에 MSB부터)
- Littel Endian:  0x100 = 67 ~ 0x103 = 01 (낮은 주소에 LSB부터)
  

  
  ---


# Fractional Point Representation
- Numerical Form : $(-1)^s$ * M * $2^E$ 
- s : sign bit
- M : 1.xxxx [1, 2) 의 범위를 가짐
>M에는 0이 아닌 유효숫자 한자리를 남김. (2진수에서는 0이 아니면 1이기 때문에 1만 남김)
- E -> exp
- M -> frac

- Single precision: 32bits
	-s = 1bit, exp = 8bits,  frac = 23bits
- Double precision: 64bits
	-s = 1bit, exp = 11bits, frac = 52bits

1. Normalized
2. Denomarlized
3. Infinity
4. NaN

### 1. Nomalized
- exp에는 0(000...0)과 255(111...1)가 아닌 값이 들어감. 즉 1<=exp<=254.
- 음수도 나타내야 하기 때문에 범위를 절반으로 나눔.
  즉 -126<=exp-127(=E)<=127
- 여기서 범위를 절반으로 나눈 값이 Bias임. E = exp - bias가 나옴.
	-bias는 unsigned로 나타낼 수 있는 값의 절반. 
	bias = $2^{bit-1}-1$ 
	
- M은 유효숫자를 나타내는데 1.xxx의 형태이므로 1이라는 값은 고정이라 표현할 필요가 없음.
- 그러므로 frac이 모두 0이면 1.000...0. 1이면 2에 가까운 수.

### 2. Denormalized
- exp = 000...0일 때
	-frac = 000...0 : 0을 나타냄
	-frac != 000..0 : 0에 근접한 아주 작은 수를 나타냄

### 3. Infinity, NaN
- exp = 111...1일 때
	-frac = 000...0 : 무한대를 나타냄.
	-frac != 000..0 : NaN을 나타냄