# Unsigned Power-of-2 Divide with Shift
-  u >> k : $2^k$ 로 나눈 몫을 구하는 것과 같다. (right shift)


    ```
    unsigned i;
    for (i = cnt-2; i>=0; i--)
	    a[i] += a[i+1];
    ```
- 문제점 : unsigned는 항상 0이상의 양의 정수를 가지기 때문에 무한 loop에 빠진다.

- 해결 코드
    ```
    unsigned i;
    for(i = cnt -2; i<cnt; i--)
		arr[i] += arr[i+1];
    ```
- i가 cnt보다 작을 때 까지만 반복 -> i의 값이 0보다 작아지게 되면 UMax가 되기 때문에 반복문 벗어남.

- x,y = signed. ux,uy = unsigned
> || 연산은 한쪽이 false임을 가정해 놓고 나머지 항이 false이면 false이다.

1.  (x > 0) || (x-1 < 0)
	   -> x<=0일 때(false 가정). x가 TMin이면 x-1은 양수가 된다.(false) = false
2.  (x & 7) != 7 || ((x << 29) < 0)
	   -> x&7은 하위 3비트만 남기겠다는 의미. 하위 3비트가 7일때, 즉 111로 끝날 때(false 가정). x<<29를 하면 하위 3비트가 상위 3비트가 되는데 MSB가 1이 되므로 무조건 음수이다(true) = true 
3.  (x * x) >= 0
	   -> singed의 곱셈은 항상 0이상의 양의 정수임을 보장할 수 없다.
4.  x < 0 || -x>=0
	   -> x>=0일 때(false 가정). x가 TMax이어도 TMin의 범위가 더 크기 때문에 항상 참이다(true) => true
5.  x > 0 || -x>=0
	   -> 위와 같은 논리로 false
6.  (x+y) == (ux + uy)
	   -> signed 의 덧셈과 unsigned의 덧셈 결과는 해석이 달라질 뿐 비트는 같다.
7.  (x * ~y) + (ux * uy) == -x
	   -> -y = ~y +1 이므로, ~y = -y-1이다. 정리하면 -xy-1 + (ux * uy) == -x
	   가 된다. signed 와 unsigned의 곱셈 결과는 해석이 달라질 뿐 비트는 변화가 없기 때문에 -xy와 ux * uy는 소거되고 -x만 남는다.

# Machine Words
- 각 컴퓨터는 "word size"가 정해져 있다.
- 한 주소는 1byte 저장   되지만, 실제로 다루는 size는 word size만큼 다룬다.

# Byte Ordering
-비트를 메모리에 저장하는 순서
> value  = 0x01234567
> address = 0x100
- Big Endian: 0x100 = 01 ~ 0x103 = 67 (낮은 주소에 MSB부터)
- Littel Endian:  0x100 = 67 ~ 0x103 = 01 (낮은 주소에 LSB부터)

  
  ---


# Fractional Point Representation
- Numerical Form : $(-1)^s$ * M * $2^E$ 
- s : sign bit
- M : 1.xxxx [1, 2) 의 범위를 가짐
>M에는 0이 아닌 유효숫자 한자리를 남김. (2진수에서는 0이 아니면 1이기 때문에 1만 남김)
- E ->frac
- M -> exp

- Single precision: 32bits - float
	-s = 1bit, exp = 8bits,  frac = 23bits
- Double precision: 64bits - double
	-s = 1bit, exp = 11bits, frac = 52bits

1. Normalized
2. Denomarlized
3. Infinity
4. NaN

### 1. Nomalized
- exp에는 0(000...0)과 255(111...1)가 아닌 값이 들어감. 즉 1<=exp<=254.
- 음수도 나타내야 하기 때문에 범위를 절반으로 나눔.
  즉 -126<=exp-127(=E)<=127
- 여기서 범위를 절반으로 나눈 값이 Bias임. E = exp - bias가 나옴.
	-bias는 unsigned로 나타낼 수 있는 값의 절반. 
	bias = $2^{exp_bit-1}-1$ 
	
- M은 유효숫자를 나타내는데 1.xxx의 형태이므로 1이라는 값은 고정이라 표현할 필요가 없음.
- 그러므로 frac이 모두 0이면 1.000...0. 1이면 2에 가까운 수.

> flaot F = 15213.0;
> 15213(10) = 11101101101101(2) 인데 이걸 float로 나타내기 위해는
> 유효숫자까지 소수점을 옮겨야됨. 이때 옮기는 만큼이 E = 13
> float이기 때문에 bias = 127. 그러므로 E = exp - bias 이므로 exp=140
> s자리에 0, exp자리에 140, frac자리에 위의 2진수를 다 넣으면
> 해당 형태로 저장됨. 
### 2. Denormalized
- 0.xxxx * $2^{1-bias}$
- exp = 000...0일 때
	-frac = 000...0 : 0을 나타냄 (0은 denormalized는 아니긴함.)
	-frac != 000..0 : 0에 근접한 아주 작은 수를 나타냄

### 3. Infinity, NaN
- exp = 111...1일 때
	-frac = 000...0 : 무한대를 나타냄.
	-frac != 000..0 : NaN을 나타냄



   ---


# Round-To-Even

- < 0.5 : 내림
> 7.894999.. : 0.4999 < 0.5 이므로 내림. 즉 7.89
- > 0.5 : 올림
> 7.8950001 : 0.50001 > 0.5 이므로 올림. 즉 7.90
- = 0.5 : 짝수 방향으로
> 7.895000 : 5를 올리면 마지막이 90이 되므로 짝수 가능. 즉 7.90
> 7.885000 : 5를 내리면 마지막이 88이 되므로 짝수 가능. 즉 7.88


- 2진수 체계에서는 마지막이 100..0 을기준으로 대소 비교
- 만약 100과 같다면 마지막 비트가 0이 되게 해야함.

# FP Multiplication

- sign bit mul : s1 ^ s2
- M mul : M1 * M2
- E mul : E1 + E2

> 만약 M>=2 라면 10.xxxx * $2^E$  E를 증가시킨다 -> 1.0xxxx *$2^{E+1}$ 
> 만약 E가 범위를 벗어난다면 overflow
> M을 frac에 맞게 round 처리한다. 