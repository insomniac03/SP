# Unsigned Power-of-2 Divide with Shift
-  u >> k : $2^k$ 로 나눈 몫을 구하는 것과 같다. (right shift)


    ```
    unsigned i;
    for (i = cnt-2; i>=0; i--)
	    a[i] += a[i+1];
    ```
- 문제점 : unsigned는 항상 0이상의 양의 정수를 가지기 때문에 무한 loop에 빠진다.

- 해결 코드
    ```
    unsigned i;
    for(i = cnt -2; i<cnt; i--)
		arr[i] += arr[i+1];
    ```
- i가 cnt보다 작을 때 까지만 반복 -> i의 값이 0보다 작아지게 되면 UMax가 되기 때문에 반복문 벗어남.

- x,y = signed. ux,uy = unsigned
> || 연산은 한쪽이 false임을 가정해 놓고 나머지 항이 false이면 false이다.

1.  (x > 0) || (x-1 < 0)
	   -> x<=0일 때(false 가정). x가 TMin이면 x-1은 양수가 된다.(false) = false
2.  (x & 7) != 7 || ((x << 29) < 0)
	   -> x&7은 하위 3비트만 남기겠다는 의미. 하위 3비트가 7일때, 즉 111로 끝날 때(false 가정). x<<29를 하면 하위 3비트가 상위 3비트가 되는데 MSB가 1이 되므로 무조건 음수이다(true) = true 
3.  (x * x) >= 0
	   -> singed의 곱셈은 항상 0이상의 양의 정수임을 보장할 수 없다.
4.  x < 0 || -x>=0
	   -> x>=0일 때(false 가정). x가 TMax이어도 TMin의 범위가 더 크기 때문에 항상 참이다(true) => true
5.  x > 0 || -x>=0
	   -> 위와 같은 논리로 false
6.  (x+y) == (ux + uy)
	   -> signed 의 덧셈과 unsigned의 덧셈 결과는 해석이 달라질 뿐 비트는 같다.
7.  (x * ~y) + (ux * uy) == -x
	   -> -y = ~y +1 이므로, ~y = -y-1이다. 정리하면 -xy-1 + (ux * uy) == -x
	   가 된다. signed 와 unsigned의 곱셈 결과는 해석이 달라질 뿐 비트는 변화가 없기 때문에 -xy와 ux * uy는 소거되고 -x만 남는다.

    ---
    

# Machine Words
- 각 컴퓨터는 "word size"가 정해져 있다.
- 한 주소는 1바이트씩 저장되지만, 실제로 다루는 size는 word size만큼 다룬다.
- 