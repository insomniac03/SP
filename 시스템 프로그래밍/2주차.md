
# Bits
- 0과 1로 이루어짐
- 해석하는 방법에 따라 num, string, data structre, command 등 다양하게 표현 가능
- 1 byte = 8 bits
- 진수에 따른 표현 -> [[c1]] 
- 운영체제에 따른 bit size -> [[c2]]

# Boolean Algebra
- 1은 True, 0은 False
- A&B : A와 B 모두 1일 때 True
- A | B : A와 B 둘 중 하나가 1일 때 True
- ~A   : A가 1이면 False, 0이면 True
- A^B : A와 B가 다르면 True, 같으면 False

# Bit-Level Operation
- bit의 각 자리를 논리값으로 보는 operation
> ex) 01101001 & 01010101 = 01000001 (AND)
> ex) 01101001  |  01010101 = 01111101 (OR)
  
# Logic Operation
- 값 자체를 논리값으로 보는 operation
- 0이 아닌 값은 모두 True
- 결과는 0x00(false) 아니면 0x01(true)
> ex) 0x69 && 0x00 = 0x00
> ex) 0x69  | |  0x55 = 0x01
- XOR연산은 없음

# Shift Operation
- Left shift: x << y
	-logical shift: 빈자리를 0으로 채움 
	
- Right shift: x >> y
	-logical shift: 빈자리를 0으로 채움
	-arithmetic shift: 빈자리를 MSB로 채움 

|               x               | 11100010 |
| :---------------------------: | :------: |
|      left shift : x << 3      | 00010000 |
| right shift(logical) : x >> 3 | 00011100 |
| right shift(arith.) : x >> 3  | 11111100 |
> shift 가능 횟수 n은 0 < n <= w


# Encoding Integers
- Unsigned: 0이상의 정수
- Signed: 부호가 있는 정수(Two's complement로 표현)
> Two's complement: MSB가 0이면 양수, 1이면 음수로 표현.
> 음수일 경우 MSB에만 음수를 붙여서 계산 or y = ~x + 1

|             | decimal |        binary         |     hex     |
| :---------: | :-----: | :-------------------: | :---------: |
| short int x |  15213  |   00111011 01101101   | [3B 6D](c1) |
| short int y | -15213  | **11000100 10010011** | [C4 93](c1) |


# Numeric Range
- Unsigned Values
	-UMin = 0 (000....0)
	-UMax = $2^w - 1$ (111...1)
-  Two's complement Values
	-TMin = $-2^{w-1}$ (MSB가 1일 때 최솟값 100...0) -> MSB만 음수고 나머지가 0이여야 더해지는 수가 없어 최솟값이 될 수 있음.
	-TMax = $2^{w-1}-1$ (MSB가 0일 때 최댓값 011...1) -> MSB가 양수고 나머지 자릿수의 값을 모두 더할 수 있어야 최댓값이 될 수 있음.
	
> Two's complement에서 정수 -1은 Binary에서 모든 자리가 1이고, Hex에서 모든 코드가 F이다

- Asymmetric range
	-|TMin| = TMax + 1
	-UMax = 2 * TMax + 1
	-UMax = 2 * |TMin|  - 1


# Unsigned & Singend Numeric Values
- bit를 unsigned와 two's complement로 해석할 때의 비교 -> [[c3]]
![[스크린샷 2025-09-14 193844.png]]
- Two's complement의 0과 양의 정수 구간에서는 Unsigned range와 1대1 대응이 된다.
- -1이 unsigned로 캐스팅이 되면 UMax로 캐스팅 된다 -> -1(111...1)은 unsinged에서 최댓값
- TMin이 unsigned로 캐스팅이 되면 TMax +1로 캐스팅 된다 -> Tmin(100...0)은 unsigned에서 Tmax(011...1)의 다음 값

# Various Casting
> 피 연산자 중 unsigned가 포함되어 있으면 signed도 unsigned로 캐스팅 후 연산

| C1                  | C2                         | Relation | Evaluation |
| ------------------- | -------------------------- | -------- | ---------- |
| 0                   | 0U                         | ==       | unsigned   |
| -1                  | 0                          | <        | signed     |
| -1 (111...1)        | 0U                         | >        | unsigned   |
| TMax                | TMin-1                     | >        | signed     |
| TMax(U) (011...1)   | TMin-1 (unsigned에서 TMax+1) | <        | unsigned   |
| -1                  | -2                         | >        | signed     |
| (unsigned)-1 (UMax) | -2 (UMax -1)               | >        | unsigned   |
| Tmax                | (Tmax+1)U                  | <        | unsigned   |
| Tmax                | int(Tmax+1)U               | >        | signed     |
> 캐스팅 시 bit pattern은 유지된다, 하지만 해석을 다르게 한다.

> 캐스팅이 일어날 시 $2^w$ 만큼 차이가 난다.
> MSB의 부호가 바뀌기 때문 (+$2^{w-1}$ 이 -$2^{w-1}$ 로 바뀜, 반대도 마찬가지)


# Sign Extension
- 값이 달라지지 않음
- MSB(0 or 1)를 확장된 bit에 복사

> 확장 전 MSB = $-2^{w-1}$
   확장 후 MSB =  $-2^{w+k-1}$ 
- 확장 후에도 값이 유지되는 이유는 $2^{w+k-2}$ 부터 $2^{w-1}$ (확장 전 MSB) 까지 더한 결과값이 $-2^{w-1}$ 이기 때문

# Truncating
- 더 작은 크기의 자료형으로 변환하는 과정은 truncating을 거친다.
- signed 에서는 값이 달라질 가능성이 높다(MSB가 날라가기 때문에.)
- unsigned : %$2^w$ 연산을 한 것과 같다
- signed :  %$2^w$ 연산과 비슷하다(값 유지 보장 X)


# Unsigned Addition
- w bit + w bit = w+1 bit 이어야 한다.
- 하지만 MSB를 날리는 방식으로 C에서는 연산을 진행한다.
- Uadd(u,v)  = (u+v) mod $2^w$ (w+1bit에서 w bit 까지만 남기기 위한 모듈러 연산)

> ![[스크린샷 2025-09-14 204210.png]]

> carry 발생 == overflow 발생
> 
> result = (u+v) mod $2^w$ 이다.


# Two's Complement Addition
- unsigned addition과 같은 방식으로 더함, 즉 결과 bit는 똑같음
- 하지만 해석을 Two's complement로 함

> carry 발생 != overflow 발생
> MSB 부호 변화 == overflow 발생 (carry가 없어도 overflow 발생 가능)


# Multiplication
- unsgined
	-UMin : 0
	-UMax : (UMax) * (UMax) = ${(2^w-1)^2}$ 
- signed
	-TMin : (Tmin) * (Tmax) = $(-2^{w-1}) * (2^{w-1}-1)$ 
	-TMax : (TMin) * (TMin) = $(-2^{w-1})^2$
> w bit 끼리의 연산 결과를 저장하는 자료형의 bit크기는 2w 가 되어야 오류 없이 자료를 저장할 수 있다


# Unsgined Multiplication
- UMul(u,v) = (u * v) mod $2^w$
- unsigned addition과 유사
- overflow를 방지하려면 $2^2w$ 만큼의 비트 공간 필요

# Signed Multiplication
- unsigned multiplication과 유사
- 해석이 달라짐(signed addtion과 유사)
- overflow를 방지하려면 $2^2w$ 만큼의 비트 공간 필요

> 상위 bit는 truncated 되어 날라가기 때문에 굳이 연산하지 않는다.

| Mode     | x        | y       | x * y       | truncated x * y |
| -------- | -------- | ------- | ----------- | --------------- |
| unsigned | 5 [101]  | 3 [011] | 15 [001111] | 7 [111]         |
| signed   | -3 [101] | 3 [011] | -9 [110111] | -1 [111]        |
> 위 표를 보면 알 수 있듯이 x * y의 기대 연산 결과에서 w개 만큼 짤린다.
> 즉, (u * v) % $2^w$ 이 결과값이 된다.


# Multiplying by Constants
-  int x, y; int z = x * y 일 때는 위와 같은 방법으로 연산 진행
-  int x; int z = 27 * x 일 때는  16x + 8x + 2x + x 처럼 
	2의 거듭제곱 형태로 표현여 shift 연산을 통해 각 값을 구한 후 더함.