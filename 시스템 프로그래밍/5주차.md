
# Implicit setting

- 산술연산, 논리연산

- CF(unsigned 일 때 의미 있음) : 연산 결과 carry가 발생할 때 CF=1.
	- unsinged일 때 carry가 발생한다는 것은 overflow가 발생했다는 것.
	- sigend일때 carry 발생 유무는 overflow와 관련이 없음.

- ZF : 연산 결과가 0일 때 ZF=1.

- SF(signed일 때 의미 있음) : MSB=1이 되면, 즉 unsigned로 해석했을 때 값이 음수이면 SF=1.

- OF(signed일 때 의미 있음) : signed일 때 덧셈 연산에서 overflow는 두가지 경우에 발생
	- 양수 + 양수 = 음수가 나올 때 OF 발생(MSB로 판단)
	- 음수 + 음수 = 양수(0포함) 나올 때 OF 발생(MSB로 판단)
	- > OF는 일단 연산을 갈기고 signed로 해석할지, unsigned로 해석할지 결정 후 OF판단.


# Explicit setting

- setting을 하기 위한 명령어

- cmpq b, a : $a-b$ 를 연산하여 flag의 상태 변경 (결과 저장 X)
	- CF = 1 : carry 발생할 때
	- ZF = 1 : a == b 일 때
	- SF = 1 : (a-b)<0 -> dest가 더 작다는 것.
	- OF = 1 : 양수 - 음수 = 음수 || 음수 - 양수 = 양수 가 나올 때

- testq b, a
	- 보통 testq %rax, %rax와 같이 같은 레지스터끼리 비교한다.
	- ZF = 1 : a&b == 0 -> %rax에 있는 값이 0
	- SF = 1 : a&b < 0 -> %rax에 있는 값이 음수

> cmpq나 testq 같이 비교하는 명령어는 비교 결과값이 중요한게 아니라 결과값이 어떤 condition flag를 on/off 시키는지가 중요함

>setg, setge 등 setX 계열의 명령어는 64비트 이지만 하위 8비트만 변화한다.
>00000000 or 00000001 나머지 비트는 movzbl %al, %eax 같은 명령어와 같이 씀.(참고)


# Jumping
- jX instructions (ex jne, jmp, je ...)
> X에 해당하는 조건에 만족되면 jX의 목표 label로 점프, jmp는 unconditional

# Conditional Move

    long func(long x, long y){
	    long result;
	    if (x>y) result = x-y;
		 else result = y-x;
		 
		 return result;
    }

- 위와 같은 코드가 있고, %rdi = x, %rsi = y, %rax = result일 때


    func:
     movq %rdi, %rax               # x를 result에
     subq %rsi, %rax                # result = x-y
     
     movq %rsi, %rdx
     subq %rdi, %rdx               # t = y-x
      **여기서 t를 만들어 if 조건을 만족하지 못할 때 리턴할 값을 임시 변수에 저장**
      
     cmpq %rsi, %rdi               # x를 y와 비교
     cmovle %rdx, %rax            # if 조건을 만족하지 못하면 result=t 후 리턴

> 조건문 내 연산이 복잡한 경우는 conditional move 사용 X
> 조건 중 유효하지 않은 동작이 포함될 수 있음.
> 원본 값에 영향을 주지 않도록 해야됨.



