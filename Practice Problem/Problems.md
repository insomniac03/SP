### 2.1

- 0x25B9D2 to binary : 0010 0101 1011 1001 1101 0010
- binary 1010 1110 0100 1001 to hexadecimal : 0xAE49
- 0xA8B3D to binary : 1010 1000 0011 1101
- binary 0011 0010 0010 1101 1001 0110 to hexadecimal : 0x322D96

### 2.2

| n   | $2^n$(decimal) | $2^n$(hexadecimal) |
| --- | -------------- | ------------------ |
| 5   | 32             | 0x20               |
| 23  |                | 0x800000           |
| 15  | 32768          | 0x8000             |
| 13  | 8192           | 0x2000             |
| 12  | 4096           | 0x1000             |
| 6   | 64             | 0x40               |
| 8   | 256            | 0x100              |

### 2.3

| Decimal              | Binary                     | Hexadecimal |
| -------------------- | -------------------------- | ----------- |
| 0                    | 0000 0000                  | 0x00        |
| 158                  | =128+16+8+4+2<br>1001 1110 | 0x9E        |
| 76                   | =64+8+4<br>0100 1100       | 0x4C        |
| 145                  | =128+16+1<br>1001 0001     | 0x91        |
| 128+32+8+4+2<br>=174 | 1010 1110                  | 0xAE        |
| 32+16+8+4<br>=60     | 0011 1100                  | 0x3C        |
| 255-8-4-2<br>=241    | 1111 0001                  | 0xF1        |
| 117                  | 0111 0101                  | 0x75        |
| 189                  | 1011 1101                  | 0xBD        |
| 245                  | 1111 0101                  | 0xF5        |

### 2.4
- 0x605c + 0x5 = 0x6061
- 0x605c - 0x20 = 0x603c
- 0x605c + 0x20 = 0x607c
- 0x60fa - 0x605c = 0x9E

### 2.5

    int a = 0x12 34 56 78;
    byte_pointer ap = (byte_pointer) &a;
    show_bytes(ap, 1); /* A. */
    show_bytes(ap, 2); /* B. */
    show_bytes(ap, 3); /* C. */

- A : Little endian: 78, Big endian: 12
- B : Little endian: 78 56, Big endian: 12 34
- C : Little endian: 78 56 34, Big endian: 12 34 56

### 2.6

- 2607352 -> hex: 0x0027C8F8
- 3510593.0 -> hex: 0x4A1F23E0

- A. binary : 0000 0000 001**0 0111 1100 1000 1111 1000**
		  : 0100 1010 0**001 1111 0010 0011 1110 00**00
- B. 21개 일치
- C. sign + exp+ 나머지 불일치.


### 2.8
- a : 0100 1110
- b : 1110 0001
	- ~a : 1011 0001
	- ~b : 0001 1110
	- a&b : 0100 0000
	- a | b : 1110 1111
	- a^ b : 1010 1111
### 2.9
> 바로 풂
### 2.10

    void inplace_swap(int *x, int *y)
    {
	    *y = *x ^ *y; /* Step 1 */
	    *x = *x ^ *y; /* Step 2 */
	    *y = *x ^ *y; /* Step 3 */
	}
- * x = a = 1010, * y = b = 1101 이라 가정하면
- step 1 : * y = 0111
- step 2 : * x = 1101(a)
- step 3 ; * y = 1010(b)

### 2.12
- x = 0x87654321일 때
- x -> 0x00000021로 변환
	- x & 0xff(하위 8비트만 1로 채워짐, 하위 8비트는 x의 21에 해당)
- x -> 0x789ABC21로 변환
	- 하위 1바이트만 제외하고 나머지는 반전됨.
	- x ^ ~0xff(반전시키고 싶은 비트에는 1, 아닌 위치는 0)
- x -> 0x876543FF로 변환
	- 하위 1바이트는 F로 만들고 나머지는 그대로
	- x | 0xff


### 2.14
- a = 0x55, b = 0x46
- 0101 0101
  0100 0110
	- a & b = 0100 0100
	- a | b = 0101 0111
	- ~a | ~b = 1011 1011
	- a & !b = 0
	- a && b = 1
	- a || b = 1
	- !a || !b = 0
	- a && ~b = 1 -> ~b는 bit level이므로 b를 반전. 그래도 0이 아니므로 && 연산결과는 1.

### 2.15
- bit, logical operation을 사용해서 x == y 이면 1, 아니면 0을 출력하도록 setting 해라.
	- x ^ y
		- x == y 이면 0x00출력
		- x != y이면 0x00이 아닌 값 출력
		- 이 때 logical operation !를 사용하면 !0x00 = 0x01 =1 이 되고
		  !0x23 = 0x00 = 0이 된다.


### 2.16

| a    |           | a<<2 |           | logical | a>>3      | arith. | a>>3      |
| ---- | --------- | ---- | --------- | ------- | --------- | ------ | --------- |
| hex  | binary    | hex  | bianry    | hex     | binary    | hex    | binary    |
| 0xD4 | 1101 0100 | 0x50 | 0101 0000 | 0x1A    | 0001 1010 | 0xFA   | 1111 1010 |
| 0x64 | 0110 0100 | 0x90 | 1001 0000 | 0xC     | 0000 1100 | 0xC    | 0000 1100 |
| 0x72 | 0111 0010 | 0xC8 | 1100 1000 | 0xE     | 0000 1110 | 0xE    | 0000 1110 |
| 0x44 | 0100 0100 | 0x10 | 0001 0000 | 0x8     | 0000 1000 | 0x8    | 0000 1000 |

### 2.17


| hex | binary | B2U | B2T |
| --- | ------ | --- | --- |
| 0xA | 1010   | 10  | -6  |
| 0x1 | 0001   | 1   | 1   |
| 0xB | 1011   | 11  | -5  |
| 0x2 | 0010   | 2   | 2   |
| 0x7 | 0111   | 7   | 7   |
| 0xC | 1100   | 12  | -4  |

### 2.19

| x   | T2U        |
| --- | ---------- |
| -1  | 1111 -> 15 |
| -5  | 1011 -> 11 |
| -6  | 1010 -> 10 |
| -4  | 1100 -> 12 |
| 1   | 0001 -> 1  |
| 8   | 1000 -> -8 |

### 2.21
- 32-bit, TMax = 2147483647

| expression                    | type     | evaluation                                                                                                                 |
| ----------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------- |
| -2147483647-1 == 2147483648U  | unsigned | false, 좌변이 TMin인데 unsgiend로 캐스팅 되면서 Tmax+1의 값을 가진다.                                                                        |
| -2147483647-1 < 2147483647    | signed   | true                                                                                                                       |
| -2147483647-1U < 2147483647   | unsigned | false, (TMin)+1의 값이 unsigend로 바뀌면서 (TMax+1) +1의 값이 되고, 여기서 1U를 빼서 뒷자리가 8이 된다.                                              |
| -2147483647-1 < -2147483647   | signed   | true                                                                                                                       |
| -2147483647 -1U < -2147483647 | unsigend | true, 좌변은 (TMin+1)의 값이 unsigned로 바뀌면서 (TMax+1)+1의 값이 되고, 여기서 -1U를 빼 TMax+1이 된다.<br>우변은 TMin+1의 값이 (TMax+1)+1이 되어 우변이 더 크다. |

### 2.23


    int fun1(unsigned word){
	    return (int) ((word << 24) >> 24);
    }
    
    int fun2(unsigned word) {
	    return ((int) word << 24) >> 24;
    }
> unsigned -> logically, signed -> arith.

-

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |


### 2.24

4-bit -> 3bit 으로 truncating

| unsgiend |           |
| -------- | --------- |
| og       | truncated |
| 1(0001)  | 1(001)    |
| 3(0011)  | 3(011)    |
| 5(0101)  | 5(101)    |
| 12(1100) | 4(100)    |
| 14(1110) | 6(110)    |

| two's    |           |
| -------- | --------- |
| og       | truncated |
| 1(0001)  | 1(001)    |
| 3(0011)  | 3(011)    |
| 5(0101)  | 5(101)    |
| -4(1100) | -4(100)   |
| -2(1110) | -2(110)   |
> 음수일때 값이 변하지 않는 이유는 MSB가 살아있기 때문(lucky)



| x   | x        | y        | x * y      | truncated |     |
| --- | -------- | -------- | ---------- | --------- | --- |
| U   | 100 : 4  | 101 : 5  | 20(010100) | 100(4)    |     |
| T   | 100 : -4 | 101 : -3 | 12(001100) | 100(-4)   |     |
| U   | 010 : 2  | 111 : 7  | 14(001110) | 110(6)    |     |
| T   | 010 : 2  | 111 : -1 | -2(111110) | 110(-2)   |     |
| U   | 110 : 6  | 110 : 6  | 36(100100) | 100(4)    |     |
| T   | 110 : -2 | 110 : -2 | 4(000100)  | 100(-4)   |     |


### 2.44

x,y : signed
ux,uy : unsigned

- (x>0) || (x-1<0) 
  : x가 Tmin이면 x-1은 TMax+1이 될 수 있다. False.
- (x & 7) != 7 || (x<<29<0) 
  : x가 7일때(00..111), x를 29비트만큼 left-shift하면 상위3비트가 111이다, 즉 음수이다. True
- (x * x) >=0 
  : x가 TMax이면 Truncated 되어 음수가 나올 수 있다. False
- x < 0 || -x <=0
  : x가 TMax이면 -x는 T의 범위에 반드시 속한다. True
- x >0 || -x >=0
  : x가 TMin이면 -x는 T의 범위에 벗어난다.(TMin의 부호를 바꾸면 TMax보다 1큼). False
- x+y == uy+ux
  : signed 덧셈과 unsigned 덧셈과 비트 형태는 같다. True
- x*~y + uy * ux == -x
  : ~y = -y-1, ~y = y-1이므로 x * (y-1) + ux * uy = xy - x + uxuy. 여기서 xy와 uxuy의 비트 형태는 같으므로 빼면 0이된다. 남는건 -x

    ---

> x,y 는 int이고 ux,uy는 unsigned(x), unsigned(y) 이다.
- A. (x<y) == (-x > -y)
  : x가 TMin이고 y가 TMin+1일 때 -y는 TMax가 되므로 false
- B. ((x+y) << 4) + y - x == 17 * y + 15 * x
  : 16x+16y + y -x == 17y + 15x.  overflow가 발생해도 대수적으로 동일.(비트 구조가 같음)
- C. ~x + ~y + 1 == ~(x+y)
  : -x = ~x + 1이므로  좌변은 -x-1-y-1+1 = -x-y-1이고, 우변은 -(x+y) -1 이므로 True.
- D. (ux-uy) == (unsigned)(x-y)
  : 좌변이 unsigned(x)- unsigned(y) == (unsigned)(x-y)이므로 True.
- E. ((x>>2)<<2) <= x
  : right-shift를 하여 상위 2비트를 x의 MSB로 만들어도 다시 상위 2비트를 지우는 left-shift를 수행하기 때문에 결과적으로 하위 2비트만 0으로 바뀐다. 이 때 원래 x의 하위 2비트가 0이었으면 연산값과 원래 x의 값이 동일하고 0이 아니라면 연산값이 x보다 더 작아진다.
  

### 2.54

>x <- int, d <- double, f <- float 

- A. x == (int)(double) x
  : int형이 표현할 수 있는 수의 범위는 32비트이고 doble이 표현할 수 있는 수의 범위는 52(+1)비트 이므로 int 범위를 cover할 수 있다. True
- B. x == (int)(float) x
  : flao가 표현할 수 있는 수의 범위는 23(+1)비트 이로 int 범위를 cover할 수 없다. False
- C. d == (double)(float) d
  : double을 float로 캐스팅 할 시 DMax의 값같이 float가 표현할 수 없는 수의 범위를 표현할 수 없다. False
- D. f == (float)(double) f
  : double의 수의 범위가 더 크므로 float를 캐스팅할수 있다.
- E. f == -(-f)
  : float는 signed 비트만 바꾸면 부호가 바뀌므로 True

f+d -f ==d
    ---

- A. (float) x == (float) dx
  : int->float(불완전), int->double(완전)->float(int의 범위 내이기 때문에 불완전) 그런데 불완전하게 변환된 값이 비트구조가 같음.

- B. dx- dy == (double) (x-y)
  : x=TMin, y=1 일 때 각각을 double로 캐스팅 후 TMin -1을 해도 정상적인 값이 나옴. bu x-y를 int 범위에서 연산을 하면 underflow가 발생하여 TMax가 되고 이 값을 double로 캐스팅하면 정상적으로 TMAx의 값이 나오므로 false.

- C. (dx + dy) + dz == dx + (dy+dz)
  : dx = 1e20, dy = 1e-20, dz = 1e20 일 때 좌변은 0 우변은 inf가 되므로 false.


- D. (dx * dy) * dz == dx * (dy * dz)
  : dx = 1e20, dy = 1e20, dz = 1e-20일 때 좌변은 inf * 작은 수 이므로 inf가 되 우변은 1e20 * 1이 되므로 1e20이 된다. false
- E. dx /dx == dz / dz
  : dx = 0이면 NaN dz = 1 1 이므로 false.