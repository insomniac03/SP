### 2.1

- 0x25B9D2 to binary : 0010 0101 1011 1001 1101 0010
- binary 1010 1110 0100 1001 to hexadecimal : 0xAE49
- 0xA8B3D to binary : 1010 1000 0011 1101
- binary 0011 0010 0010 1101 1001 0110 to hexadecimal : 0x322D96

### 2.2

| n   | $2^n$(decimal) | $2^n$(hexadecimal) |
| --- | -------------- | ------------------ |
| 5   | 32             | 0x20               |
| 23  |                | 0x800000           |
| 15  | 32768          | 0x8000             |
| 13  | 8192           | 0x2000             |
| 12  | 4096           | 0x1000             |
| 6   | 64             | 0x40               |
| 8   | 256            | 0x100              |

### 2.3

| Decimal              | Binary                     | Hexadecimal |
| -------------------- | -------------------------- | ----------- |
| 0                    | 0000 0000                  | 0x00        |
| 158                  | =128+16+8+4+2<br>1001 1110 | 0x9E        |
| 76                   | =64+8+4<br>0100 1100       | 0x4C        |
| 145                  | =128+16+1<br>1001 0001     | 0x91        |
| 128+32+8+4+2<br>=174 | 1010 1110                  | 0xAE        |
| 32+16+8+4<br>=60     | 0011 1100                  | 0x3C        |
| 255-8-4-2<br>=241    | 1111 0001                  | 0xF1        |
| 117                  | 0111 0101                  | 0x75        |
| 189                  | 1011 1101                  | 0xBD        |
| 245                  | 1111 0101                  | 0xF5        |

### 2.4
- 0x605c + 0x5 = 0x6061
- 0x605c - 0x20 = 0x603c
- 0x605c + 0x20 = 0x607c
- 0x60fa - 0x605c = 0x9E

### 2.5

    int a = 0x12 34 56 78;
    byte_pointer ap = (byte_pointer) &a;
    show_bytes(ap, 1); /* A. */
    show_bytes(ap, 2); /* B. */
    show_bytes(ap, 3); /* C. */

- A : Little endian: 78, Big endian: 12
- B : Little endian: 78 56, Big endian: 12 34
- C : Little endian: 78 56 34, Big endian: 12 34 56

### 2.6

- 2607352 -> hex: 0x0027C8F8
- 3510593.0 -> hex: 0x4A1F23E0

- A. binary : 0000 0000 001**0 0111 1100 1000 1111 1000**
		  : 0100 1010 0**001 1111 0010 0011 1110 00**00
- B. 21개 일치
- C. sign + exp+ 나머지 불일치.


### 2.8
- a : 0100 1110
- b : 1110 0001
	- ~a : 1011 0001
	- ~b : 0001 1110
	- a&b : 0100 0000
	- a | b : 1110 1111
	- a^ b : 1010 1111
### 2.9
> 바로 풂
### 2.10

    void inplace_swap(int *x, int *y)
    {
	    *y = *x ^ *y; /* Step 1 */
	    *x = *x ^ *y; /* Step 2 */
	    *y = *x ^ *y; /* Step 3 */
	}
- * x = a = 1010, * y = b = 1101 이라 가정하면
- step 1 : * y = 0111
- step 2 : * x = 1101(a)
- step 3 ; * y = 1010(b)

### 2.12
- x = 0x87654321일 때
- x -> 0x00000021로 변환
	- x & 0xff(하위 8비트만 1로 채워짐, 하위 8비트는 x의 21에 해당)
- x -> 0x789ABC21로 변환
	- 하위 1바이트만 제외하고 나머지는 반전됨.
	- x ^ ~0xff(반전시키고 싶은 비트에는 1, 아닌 위치는 0)
- x -> 0x876543FF로 변환
	- 하위 1바이트는 F로 만들고 나머지는 그대로
	- x | 0xff


### 2.14
- a = 0x55, b = 0x46
- 0101 0101
  0100 0110
	- a & b = 0100 0100
	- a | b = 0101 0111
	- ~a | ~b = 1011 1011
	- a & !b = 0
	- a && b = 1
	- a || b = 1
	- !a || !b = 0
	- a && ~b = 1 -> ~b는 bit level이므로 b를 반전. 그래도 0이 아니므로 && 연산결과는 1.

### 2.15
- bit, logical operation을 사용해서 x == y 이면 1, 아니면 0을 출력하도록 setting 해라.
	- x ^ y
		- x == y 이면 0x00출력
		- x != y이면 0x00이 아닌 값 출력
		- 이 때 logical operation !를 사용하면 !0x00 = 0x01 =1 이 되고
		  !0x23 = 0x00 = 0이 된다.


### 2.16

| a    |           | a<<2 |           | logical | a>>3      | arith. | a>>3      |
| ---- | --------- | ---- | --------- | ------- | --------- | ------ | --------- |
| hex  | binary    | hex  | bianry    | hex     | binary    | hex    | binary    |
| 0xD4 | 1101 0100 | 0x50 | 0101 0000 | 0x1A    | 0001 1010 | 0xFA   | 1111 1010 |
| 0x64 | 0110 0100 | 0x90 | 1001 0000 | 0xC     | 0000 1100 | 0xC    | 0000 1100 |
| 0x72 | 0111 0010 | 0xC8 | 1100 1000 | 0xE     | 0000 1110 | 0xE    | 0000 1110 |
| 0x44 | 0100 0100 | 0x10 | 0001 0000 | 0x8     | 0000 1000 | 0x8    | 0000 1000 |

### 2.17


| hex | binary | B2U | B2T |
| --- | ------ | --- | --- |
| 0xA | 1010   | 10  | -6  |
| 0x1 | 0001   | 1   | 1   |
| 0xB | 1011   | 11  | -5  |
| 0x2 | 0010   | 2   | 2   |
| 0x7 | 0111   | 7   | 7   |
| 0xC | 1100   | 12  | -4  |

### 2.19

| x   | T2U        |
| --- | ---------- |
| -1  | 1111 -> 15 |
| -5  | 1011 -> 11 |
| -6  | 1010 -> 10 |
| -4  | 1100 -> 12 |
| 1   | 0001 -> 1  |
| 8   | 1000 -> -8 |

### 2.21
- 32-bit, TMax = 2147483647

| expression                    | type     | evaluation                                                                                                                 |
| ----------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------- |
| -2147483647-1 == 2147483648U  | unsigned | false, 좌변이 TMin인데 unsgiend로 캐스팅 되면서 Tmax+1의 값을 가진다.                                                                        |
| -2147483647-1 < 2147483647    | signed   | true                                                                                                                       |
| -2147483647-1U < 2147483647   | unsigned | false, (TMin)+1의 값이 unsigend로 바뀌면서 (TMax+1) +1의 값이 되고, 여기서 1U를 빼서 뒷자리가 8이 된다.                                              |
| -2147483647-1 < -2147483647   | signed   | true                                                                                                                       |
| -2147483647 -1U < -2147483647 | unsigend | true, 좌변은 (TMin+1)의 값이 unsigned로 바뀌면서 (TMax+1)+1의 값이 되고, 여기서 -1U를 빼 TMax+1이 된다.<br>우변은 TMin+1의 값이 (TMax+1)+1이 되어 우변이 더 크다. |

### 2.23


    int fun1(unsigned word){
	    return (int) ((word << 24) >> 24);
    }
    
    int fun2(unsigned word) {
	    return ((int) word << 24) >> 24;
    }
> unsigned -> logically, signed -> arith.

-

| w          | fun1(w)    | fun2(w)    |
| ---------- | ---------- | ---------- |
| 0x00000076 | 0x00000076 | 0x00000076 |
| 0x87654321 | 0x00000021 | 0x00000021 |
| 0x000000C9 | 0x000000C9 | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087 | 0xFFFFFF87 |


### 2.24

4-bit -> 3bit 으로 truncating

| unsgiend |           |
| -------- | --------- |
| og       | truncated |
| 1(0001)  | 1(001)    |
| 3(0011)  | 3(011)    |
| 5(0101)  | 5(101)    |
| 12(1100) | 4(100)    |
| 14(1110) | 6(110)    |

| two's    |           |
| -------- | --------- |
| og       | truncated |
| 1(0001)  | 1(001)    |
| 3(0011)  | 3(011)    |
| 5(0101)  | 5(101)    |
| -4(1100) | -4(100)   |
| -2(1110) | -2(110)   |
> 음수일때 값이 변하지 않는 이유는 MSB가 살아있기 때문(lucky)
